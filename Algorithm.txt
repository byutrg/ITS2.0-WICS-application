Algorithm to preserve ITS markup during conversion to HTML by removing all XPaths and localizing global rules:

Create array containing all its:*Rule elements (internal or referenced), in order of application
    order should be external, internal, external, internal, etc. in order of document appearance
    (later rules will override earlier ones, as per spec)

# In this loop, create $matchIndex to remember which rules match which elements
loop over ITS:xyzRule elements
    for $match (document element matches for selector attribute)
		if the rule is one of idValueRule, langRule, or preserveSpaceRule, apply it
			(these change actual XML document structure, so they should be applied in case a rule selector requires it)
			(see Question 2)
        if $match doesn't already have or inherit a local rule of the same type
            if it has its:*Pointer attribute:
                $pointerVal = contents of resolved XPath
                    (see note 1.)
            $matchIndex->{$match}->{xyzRule} = [$rule, $pointerVal || undef]
                (this overwrites previous matches, preserving precedence)
delete its:rules elements

loop all other document elements
    save name and attributes other than xml:id and xml:lang in title
        (see note 2.)
        (see Question 3.)
    save xml:id and xml:lang as id and lang
        (need to keep id and lang because its:[idValue|lang]Rule might have created them, and we want to keep ITS data; also, the ID could be important for matching the HTML output with the original XML input. Language is pretty obviously important information for internationalization)
    delete all of the attributes saved in the title
    rename element to span or div, depending on inlininess

(Note: this could be combined with the loop above)
loop $element in $match_index
    loop [$rule, $pointerVal] in $match_index->{$element}->{(all rule names)}
        localize $rule onto $element
        if $pointerVal is defined
            set the corresponding non-pointer attribute on the element to $pointerVal
                (e.g. locNoteRefPointer value becomes locNoteRef)
                (Note 1.)

Paste the entire transformed document into the boilerplate for an HTML document (with html, head, title and body elements).

Overall complexity is around m + n (m is number of rules, n is elements in document)

---END---

############ QUESTIONS #############
Question 1-
The ITS spec is unclear (to me) on precedence in the following case:
    document contains two its:rules elements (r1 and r2)
    each contains various its:*rule elements and an external its:rules references (e1 and e2)
They are supposed to be applied in document order, later ones overriding earlier ones.
Should they be applied r1 r2 e1 e2, or r1 e1 r2 e2 (I think it's the latter)?

Answer 1: e1 r1 e2 r2 (later ones overriding earlier ones)

Question 2- say I have an its:rules like this:
<its:rules>
<its:locNoteRule selector="id(b)" .../>
<its:idValueRule selector="//a" idValue="@id_val"/>
</its:rules>

And then there's a document element <a id_val="b"/>.
Should the locNoteRule apply first, not matching anything, and then the idValueRule match apply, giving a an id? Or should the rules that change the actual XML instead of adding ITS markup apply first, so that here a would have id="b" and the locNoteRule would apply to it?

Answer 2: I think that in such rule lists the rules apply in the order of their appearance.

Question 3-
Is saving all of the attributes of an element in the title overkill? Note that with this algorithm there's no actual need to save the tag name or the attributes. It's only for display purpose (originally I was saving the tag name to match via XPath, but now I don't do that).

############ NOTES #############
Note 1- why not preserve pointers as pointers?
    Because during HTML conversion we blow away most attributes. Let's say there were an element <a url="http://example.com"/> and a locNoteRefPointer referred to the url att via something like "../a/@url". The element might become <span title="a[@url='http://example.com']/>". So if we wanted to preserve the ITS pointer-ness, then we would have to 1. save the element which is being referred to by this pointer before the document is converted into HTML, 2. also save the attribute being referred to, and 3. after the document is converted, create an XPath expression to extract the value of that attribute out of the referred-to element's title attribute; if we want the old url attribute contained in the title, we would have to create an expression like
Note 2- why not save the namespace in the title attribute?
    1. This is just for display on mouse-over, not for matching with XPath
    2. once we delete the atts from the element in the current loop iteration, the namespace won't even be available on the children for saving, so consistency would not be possible