Algorithm to preserve ITS markup during conversion to HTML by removing all XPaths and localizing global rules:

Create array containing all its:rules elements (internal or referenced), in order of application
    (later rules will override earlier ones, as per spec)
    (Question 1)

Loop over each its:rules elements
    loop all its:idValRule elements
        apply, setting xml:id values on matches
    loop all its:langRule elements
        apply, setting xml:lang values on matches
    loop all its:preserveSpaceRule elements
        apply, setting xml:space values on matches

# In this loop, create $matchIndex to remember which rules match which elements
loop over ITS:xyzRule elements in ITS:rules
    for $match (document element matches for selector attribute)
        if $match doesn't already have local rule of same type
            if it has its:*Pointer attribute:
                $pointerVal = contents of resolved XPath
                    (see note 1.)
            $matchIndex->{$match}->{xyzRule} = [$rule, $pointerVal || undef]
                (this overwrites previous matches, preserving precedence)
delete given ITS:rules element

loop all other document elements
    save name and attributes other than xml:id and xml:lang in title
        (see note 2.)
    save xml:id and xml:lang as id and lang
        (need to keep id and lang because its:[idValue|lang]Rule might have created them, and we want to keep ITS data; also, the ID could be important for matching the HTML output with the original XML input. Language is pretty obviously important information for internationalization)
    delete all of the attributes saved in the title
    rename element to span or div, depending on inlininess

loop $element in $match_index
    loop [$rule, $pointerVal] in $match_index->{$element}->{(all rule names)}
        localize $rule onto $element
        if $pointerVal is defined
            set the corresponding non-pointer attribute on the element to $pointerVal
                (e.g. locNoteRefPointer value becomes locNoteRef)
                (Note 1.)

Paste the entire transformed document into the boilerplate for an HTML document (with html, head, title and body elements).

---END---

############ QUESTIONS #############
Question 1-
The ITS spec is unclear (to me) on precedence in the following case:
    document contains two its:rules elements (r1 and r2)
    each contains various its:*rule elements and an external its:rules references (e1 and e2)
They are supposed to be applied in document order, later ones overriding earlier ones.
Should they be applied r1 r2 e1 e2, or r1 e1 r2 e2 (I think it's the latter)?


############ NOTES #############
Note 1- why not preserve pointers as pointers?
    Because during HTML conversion we blow away most attributes. Let's say there were an element <a url="http://example.com"/> and a locNoteRefPointer referred to the url att via something like "../a/@url". The element might become <span title="a[@url='http://example.com']/>". So if we wanted to preserve the ITS pointer-ness, then we would have to 1. save the element which is being referred to by this pointer before the document is converted into HTML, 2. also save the attribute being referred to, and 3. after the document is converted, create an XPath expression to extract the value of that attribute out of the referred-to element's title attribute; if we want the old url attribute contained in the title, we would have to create an expression like
Note 2- why not save the namespace in the title attribute?
    1. This is just for display on mouse-over, not for matching with XPath
    2. once we delete the atts from the element in the current loop iteration, the namespace won't even be available on the children for saving, so consistency would not be possible