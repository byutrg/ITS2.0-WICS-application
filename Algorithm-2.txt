Algorithm to preserve ITS markup during conversion to HTML by replacing global selectors with new ones.

Outline:
Grab all rules and store in order of application
    store parameter values in rules
Find all document matches, store in an index
    for each rule, store matched elements and pointer elements
        for non-elements, create new ones to represent selected data (but don't insert in document yet), and also save future insertion point (prev/next sibling, parent)
Transform document into HTML
    keep element IDs
    change elements to div or span
    #store attributes as child spans (<span title="att_name" class="_ATT" id="parentId-name">value</span>)
    put inside html structure (html, head, title, body)
Change rule selectors

__________
Details:
----------

Create array containing all its:*Rule elements (internal or referenced), in order of application
    (order should be external, internal, external, internal, etc. in order of document appearance)
    initialize $paramIndex
    [function: GET_RULES(file, $paramIndex)] for each its:rules element in file
        init @rules
        store its:param's in $paramIndex
        if there is an external rules reference,
            push GET_RULES(referenced file, $paramIndex) onto @rules
        for each its:*rule in element
            push rule onto @rules
            rule should have reference to current $paramIndex entries
        remove params from $paramIndex
        return @rules

(Loop through rules and create match index and objects to be pasted to tree later)
init $matchIndex
init $placeholders
for $rule in rules
    @nodes = matches($rule.selector)
    if($rule has pointer att)
        for $node in @nodes
            push @{$matchIndex->{$rule}}, [getNode($placeholders, $node), getNode($placeholders, $rule.pointer)]
    else
        for $node in @nodes
            push @{$matchIndex->{$rule}}, getNode($placeholders, $node)

    [function: GET_NODE($domNode)]
    switch(nodetype($domNode))
        case ELEMENT:
            return placeholder object
                (use existing placeholder if found in %placeholders)
                (placeholder just holds element, and paste does nothing)
            return $domNode;
            break;
        case ATTRIBUTE, COMMENT, PI, DOCUMENT, NAMESPACE:
            return placeholder object
                (use existing placeholder if found in %placeholders)
                (create new element representing $domNode;
                    also save prev/next sibling/parent)
        case TEXT:
            push @{$matchIndex->{$rule}}, placeholder object
                (use existing placeholder if found in %placeholders)
                (create new element representing $domNode;
                    also save prev/next sibling/parent;
                    should destroy original text when pasted into document)

put document in html/body, add head, title and encoding

for $element in document
    if $element.namespace is its (standoff)
        put in script tag in head
        next
    save $element.name in title
    for $att in $element
        switch $att.name
            CASE xml:id
                becomes id;
            CASE xml:lang
                becomes lang
            CASE: its:translate
                becomes translate
            CASE: its:dir
                becomes dir (may need finagling of values)
            CASE: its:* (besides above)
                convert to html version
            DEFAULT:
                save in title
                delete
    rename element to span or div, depending on inlininess

init @newRules
for [$rule, $nodeMatch, $nodePointerMatch] in $matchIndex
    ensure $nodeMatch has an id att
    call $nodeMatch->paste (if applicable)
    if $nodePointerMatch is defined
        ensure $nodePointerMatch has an id att
        call $nodePointerMatch->paste (if applicable)
        create $newRule
            same atts as $rule, except:
                selector selects "id('$nodeMatch->id')"
                pointer selects "id('$nodePointerMatch->id')"
        push @newRules, $newRule

create new its:rules element containing data of @newRules
paste in script element in head

done!

(Next: define classes and their interactions/roles)
